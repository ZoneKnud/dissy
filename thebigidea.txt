/**
 * Pong Multiplayer Game - Local Network (LAN) Architecture
 *
 * This document outlines the architecture for a decentralized-hybrid multiplayer Pong game
 * designed to run on a local network. It specifies the communication protocols,
 * message formats, and a simple peer-to-peer discovery mechanism.
 *
 * All communication will use UDP and TCP on port 15243.
 *
 * @author Your Name Here
 * @date 2025-09-12
 */

// -----------------------------------------------------------------------------
// 1. PROTOCOL AND CONSTANTS
// -----------------------------------------------------------------------------

const int GAME_PORT = 15243;
const int HEARTBEAT_INTERVAL_MS = 1000;
const int HEARTBEAT_TIMEOUT_MS = 3000;

// All messages will be JSON strings.
// A message should always have a 'type' field.
// {
//     "type": "some_message_type",
//     "data": { ... }
// }

// -----------------------------------------------------------------------------
// 2. MESSAGE TYPES AND STRUCTURES
// -----------------------------------------------------------------------------

/**
 * Message Types:
 * - DISCOVERY_REQUEST:   Broadcast message sent by a new player to find a host.
 * - DISCOVERY_RESPONSE:  Unicast message from a host to a new player.
 * - PLAYER_JOIN:         Unicast message from a client to the host, or from the host
 * to all clients to announce a new player.
 * - PLAYER_LEAVE:        Unicast message to announce a player has left.
 * - PADDLE_INPUT:        Real-time paddle movement data.
 * - GAME_STATE:          The full state of the game.
 * - ELECTION:            Message to initiate a new host election.
 * - ELECTION_OKAY:       Response to an election message.
 * - NEW_LEADER:          Announcement of a new host.
 */

// 2.1. Discovery Messages (UDP)

// Sent by a new client to find a host.
interface DiscoveryRequest {
    type: "DISCOVERY_REQUEST";
    data: {
        playerId: string; // Unique ID for the new client
    };
}

// Sent by a host in response to a DiscoveryRequest.
interface DiscoveryResponse {
    type: "DISCOVERY_RESPONSE";
    data: {
        leaderId: string;
        leaderIp: string;
        players: { id: string, ip: string }[]; // List of all players
    };
}

// 2.2. Game Messages (TCP and UDP)

// TCP: Sent by a client to the host. Also sent by the host to all clients
// to announce a new player has successfully joined.
interface PlayerJoin {
    type: "PLAYER_JOIN";
    data: {
        playerId: string;
        playerIp: string;
    };
}

// UDP: Real-time paddle position from a client to the host.
interface PaddleInput {
    type: "PADDLE_INPUT";
    data: {
        playerId: string;
        paddlePosition: number; // Y-coordinate of the paddle
    };
}

// UDP: Full game state from host to all clients.
interface GameState {
    type: "GAME_STATE";
    data: {
        ballPosition: { x: number, y: number };
        paddlePositions: { [playerId: string]: number }; // Map of player IDs to paddle positions
        scores: { [playerId: string]: number };
        // ... any other relevant game data
    };
}

// 2.3. Leader Election Messages (UDP)

// Sent by a client to others with a higher ID.
interface ElectionMessage {
    type: "ELECTION";
    data: {
        senderId: string;
    };
}

// Sent by a client with a higher ID to an election initiator.
interface ElectionOkay {
    type: "ELECTION_OKAY";
    data: {
        senderId: string;
    };
}

// Sent by the new leader to all other clients.
interface NewLeader {
    type: "NEW_LEADER";
    data: {
        newLeaderId: string;
        newLeaderIp: string;
    };
}

// -----------------------------------------------------------------------------
// 3. GAME FLOW AND STATE MANAGEMENT
// -----------------------------------------------------------------------------

/**
 * 3.1. Game Discovery and Connection
 *
 * 1. A new player launches the game and sends a `DISCOVERY_REQUEST` UDP broadcast on port `GAME_PORT`.
 * 2. The host (the current leader) receives the broadcast. It responds with a `DISCOVERY_RESPONSE` UDP unicast to the new player.
 * 3. The new player receives the `DISCOVERY_RESPONSE` and establishes a reliable **TCP connection** to the host.
 * 4. The host sends a `PLAYER_JOIN` message (via TCP) to all existing clients to update their list of players.
 */

/**
 * 3.2. Real-time Game Communication
 *
 * - **Clients to Host (UDP):** Clients continuously send their `PADDLE_INPUT` messages to the host.
 * - **Host to Clients (UDP):** The host is the single source of truth for game state. It runs the game logic and sends a `GAME_STATE` message via UDP multicast to all connected clients at a high frequency (e.g., 30-60 times per second).
 */

/**
 * 3.3. Host Migration (Bully Algorithm)
 *
 * - **Heartbeat:** The host sends a "heartbeat" `GAME_STATE` message (or a dedicated `HEARTBEAT` message) every second to all clients.
 * - **Timeout:** If a client doesn't receive a heartbeat from the host within `HEARTBEAT_TIMEOUT_MS`, it assumes the host is down.
 * - **Election:** The client with the highest player ID (string-based comparison is fine) sends a `ELECTION` message to all players with a higher ID. If it receives no `ELECTION_OKAY` messages from them, it declares itself the new leader.
 * - **New Leader:** The new leader sends a `NEW_LEADER` message to all other players. All clients then re-establish a **TCP connection** to the new host.
 *
 * This process ensures that the game can recover from a host's disconnection.
 */

// -----------------------------------------------------------------------------
// 4. IMPLEMENTATION NOTES
// -----------------------------------------------------------------------------

/**
 * - Player IDs can be generated as UUIDs or simply by their local IP address,
 * to ensure uniqueness.
 * - The number of paddles and the game's geometry (triangle, square, etc.)
 * is dynamically determined by the number of players in the host's player list.
 * - For UDP multicast, use the standard multicast group address range (e.g., 224.0.0.0 to 239.255.255.255).
 */
